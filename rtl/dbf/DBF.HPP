#ifndef _DBFHPP
#define _DBFHPP

#include "base.hpp"
#include "convert.hpp"

class DBF : public BASE
{
  char fltr;       // 0-не уст.,1-уст.,2-вкл.
  char write;      // 0-запись не производилаь
  char del;        // 0-удаление не производилось
  unsigned b_size; // по умолчанию = 10 записей

public:
  DBF();
  ~DBF();
  //----------------------------------------------------------------------
  //   Use - открывает файл
  //   параметры: имя, размер буфера в записях
  //----------------------------------------------------------------------

  long Use(char *, unsigned = 10);

  //----------------------------------------------------------------------
  //   Creat - создает новый фал
  //   параметры: имя, количество полей, массив стрктур FIELD, переключатель
  //   Пример: FIELD field[3]= FIELD("имя1",тип1,длина1,кол.дес.1),
  //                           FIELD("имя2",тип2,длина2,кол.дес.2),
  //                           FIELD("имя3",тип3,длина3,кол.дес.3);
  //   Переключатель: 0 - усечение сущ. файла 1 - без усечения
  //----------------------------------------------------------------------
  int Creat(char *, int, FIELD *, int);

  //----------------------------------------------------------------------
  //  Go - переход к нужной записи
  //  параметры: номер записи
  //----------------------------------------------------------------------

  int Go(long);

  //----------------------------------------------------------------------
  //  Filter_set - установка фильтра-строки в стек фильтра
  //  параметры: текстовая строка с отношениями
  //----------------------------------------------------------------------

  int Filter_set(char *); // установка фильтра

  //----------------------------------------------------------------------
  //  Filter_pop - очистка одной строки-фильтра
  //----------------------------------------------------------------------

  void Filter_pop(void); // очистка одной строки-фильтра

  //----------------------------------------------------------------------
  //  Filter_reset - очистка стека фильтров
  //----------------------------------------------------------------------

  void Filter_reset(void);

  //----------------------------------------------------------------------
  //  Close - закрывает файл DBF
  //----------------------------------------------------------------------

  void Close(void); // закрывает DBF-файл

  //----------------------------------------------------------------------
  //  Pack - переносит в новый файл не помеченные для удаления записи,
  //         старый файл оставляет с расширением BAK
  //----------------------------------------------------------------------

  int Pack(void); // "упаковывает" файл

  //-------работа с полями -----------
  // функции работы с полями возвращают значения:
  int F_ref(char *);      // лог. номер поля по имени
  char *F_name(int f_ref) // имя по номеру
  {
    return fields[f_ref - 1].name;
  }
  int F_width(int f_ref) // длина поля по номеру
  {
    return (int)(fields[f_ref - 1].width);
  }
  char F_type(int f_ref) // тип поля по номеру
  {
    return fields[f_ref - 1].type;
  }
  char *F_ptr(int f_ref) // указатель в буфере на поле по номеру
  {
    return buffer + fields[f_ref - 1].offset;
  }
  int F_true(int f_ref); // зачение лог. поля
  int F_decim(int f_ref) // кол-во цифр после запятой числ. поля
  {
    return fields[f_ref - 1].decimals;
  }
  int F_count(void) // кол-во полей базы данных
  {
    return num_fields;
  }
  double F_value(int f_ref) // значение числового поля
  {
    return atod(F_ptr(f_ref), F_width(f_ref));
  }
  //--------работа с записями ---------
  long First(long);   // поиск с использованием фильтра
  long Next(int = 0); // продолжение поиска
                      // 0-c текущей, 1-с текущей+1
  int R_put(void *);  // заполнение записи из структуры
  int R_get(void *);  // заполнение структуры из записи
  int R_write(void);  // запись тек. записи на диск
  long R_count(void)  // количество записей
  {
    return head.numb_rec;
  }
  long R_search(long, char *, void *, ...); // поиск по шаблону
  long R_search(long rec, int (*)(DBF *));  // поиск с внешней ф. сравнения
  long R_blank(void);                       // добавление пустой записи в конец файла
  long R_del(void);                         // логическое удаление текущей записи
  long R_undel(void);                       // отмена удаления
  long R_copy(long);                        // копирование текущей записи в запись с номером
  long R_get_next(void *, long);            //чтение с заполнением,int !=0-
                                            //перейти к long записи,=0 - перейти к следующей
                                            //возвращает номер записи,-1 если ошибка,0 - конец файла
};

#endif