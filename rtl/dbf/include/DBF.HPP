#ifndef  _DBFHPP
#define  _DBFHPP

#include "base.hpp"
#include "convert.hpp"

class  DBF : public BASE {
   char fltr;         // 0-не уст.,1-уст.,2-вкл.
   char write;         // 0-запись не производилаь
   char del;	       // 0-удаление не производилось
   unsigned b_size;    // по умолчанию = 10 записей

	 public:
	  pascal DBF ();
	  pascal ~DBF();
//----------------------------------------------------------------------
//   Use - открывает файл
//   параметры: имя, размер буфера в записях
//----------------------------------------------------------------------

  long pascal Use(char *,unsigned = 10);

//----------------------------------------------------------------------
//   Creat - создает новый фал
//   параметры: имя, количество полей, массив стрктур FIELD, переключатель
//   Пример: FIELD field[3]= FIELD("имя1",тип1,длина1,кол.дес.1),
//                           FIELD("имя2",тип2,длина2,кол.дес.2),
//                           FIELD("имя3",тип3,длина3,кол.дес.3);
//   Переключатель: 0 - усечение сущ. файла 1 - без усечения
//----------------------------------------------------------------------
   int pascal Creat(char *,int,FIELD*,int);

//----------------------------------------------------------------------
//  Go - переход к нужной записи
//  параметры: номер записи
//----------------------------------------------------------------------

   int pascal Go(long);

//----------------------------------------------------------------------
//  Filter_set - установка фильтра-строки в стек фильтра
//  параметры: текстовая строка с отношениями
//----------------------------------------------------------------------

   int pascal Filter_set(char*);             // установка фильтра

//----------------------------------------------------------------------
//  Filter_pop - очистка одной строки-фильтра
//----------------------------------------------------------------------

  void pascal Filter_pop(void);             // очистка одной строки-фильтра

//----------------------------------------------------------------------
//  Filter_reset - очистка стека фильтров
//----------------------------------------------------------------------

  void pascal Filter_reset(void);

//----------------------------------------------------------------------
//  Close - закрывает файл DBF
//----------------------------------------------------------------------

  void pascal Close(void);                   // закрывает DBF-файл

//----------------------------------------------------------------------
//  Pack - переносит в новый файл не помеченные для удаления записи,
//         старый файл оставляет с расширением BAK
//----------------------------------------------------------------------

   int pascal Pack(void);                    // "упаковывает" файл

   //-------работа с полями -----------
   // функции работы с полями возвращают значения:
   int pascal F_ref(char*);       // лог. номер поля по имени
   char *F_name(int f_ref)       // имя по номеру
    {  return fields[f_ref-1].name;
    }
   int  F_width(int f_ref)      // длина поля по номеру
    {  return (int)(fields[f_ref-1].width);
    }
   char F_type(int f_ref)       // тип поля по номеру
    {  return fields[f_ref-1].type;
    }
   char *F_ptr(int f_ref)        // указатель в буфере на поле по номеру
    {  return buffer+fields[f_ref-1].offset;
    }
   int  pascal  F_true(int f_ref);       // зачение лог. поля
   int  F_decim(int f_ref)       // кол-во цифр после запятой числ. поля
    { return fields[f_ref-1].decimals;
    }
   int F_count(void)      // кол-во полей базы данных
    { return num_fields;
    }
   double  F_value(int f_ref)      // значение числового поля
    {  return atod(F_ptr(f_ref),F_width(f_ref));
    }
  //--------работа с записями ---------
   long  pascal First(long);        // поиск с использованием фильтра
   long  pascal Next(int =0);       // продолжение поиска
							 // 0-c текущей, 1-с текущей+1
   int   pascal R_put(void*);       // заполнение записи из структуры
   int   pascal R_get(void*);       // заполнение структуры из записи
   int   pascal R_write(void);      // запись тек. записи на диск
   long  R_count(void)      // количество записей
    {   return head.numb_rec;
    }
   long         R_search(long,char*,void*,...);   // поиск по шаблону
   long  pascal R_search(long rec,int (*)(DBF*)); // поиск с внешней ф. сравнения
   long  pascal R_blank(void);      // добавление пустой записи в конец файла
   long  pascal R_del(void);        // логическое удаление текущей записи
   long  pascal R_undel(void);      // отмена удаления
   long  pascal R_copy(long);       // копирование текущей записи в запись с номером
   long  pascal R_get_next(void *,long);//чтение с заполнением,int !=0-
   //перейти к long записи,=0 - перейти к следующей
   //возвращает номер записи,-1 если ошибка,0 - конец файла
  };
#endif